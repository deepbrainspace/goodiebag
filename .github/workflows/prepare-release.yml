name: Prepare Release

on:
  issue_comment:
    types: [created]

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  # Only run if comment contains "prepare_release" and is on a PR
  prepare-release:
    name: üöÄ Prepare Release
    runs-on: ubuntu-latest
    if: |
      github.event.issue.pull_request &&
      contains(github.event.comment.body, 'prepare_release')
    
    steps:
      - name: Acknowledge request
        run: |
          echo "üìù Acknowledging release preparation request..."
          gh pr comment ${{ github.event.issue.number }} --body "ü§ñ **Release preparation started...**

Request by @${{ github.event.comment.user.login }} acknowledged. Checking CI status..."
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Get PR details
        id: pr
        run: |
          echo "üîç Getting PR details..."
          PR_NUMBER=${{ github.event.issue.number }}
          
          # Get PR details using GitHub API
          PR_DATA=$(gh api repos/${{ github.repository }}/pulls/$PR_NUMBER)
          PR_HEAD_SHA=$(echo "$PR_DATA" | jq -r '.head.sha')
          PR_BASE_SHA=$(echo "$PR_DATA" | jq -r '.base.sha')
          PR_HEAD_REF=$(echo "$PR_DATA" | jq -r '.head.ref')
          
          echo "pr-number=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "head-sha=$PR_HEAD_SHA" >> $GITHUB_OUTPUT
          echo "base-sha=$PR_BASE_SHA" >> $GITHUB_OUTPUT
          echo "head-ref=$PR_HEAD_REF" >> $GITHUB_OUTPUT
          
          echo "üìã PR #$PR_NUMBER"
          echo "üìã Head SHA: $PR_HEAD_SHA"
          echo "üìã Base SHA: $PR_BASE_SHA"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Check CI status
        id: ci-check
        run: |
          echo "üîç Checking CI status for PR #${{ steps.pr.outputs.pr-number }}..."
          
          # Get check runs for the head SHA
          CHECK_RUNS=$(gh api repos/${{ github.repository }}/commits/${{ steps.pr.outputs.head-sha }}/check-runs)
          
          # Check if any checks are in progress
          IN_PROGRESS=$(echo "$CHECK_RUNS" | jq -r '.check_runs[] | select(.status != "completed") | .name' | wc -l)
          
          if [ "$IN_PROGRESS" -gt 0 ]; then
            echo "‚è≥ CI is still running. Found $IN_PROGRESS checks in progress."
            echo "ci-status=in-progress" >> $GITHUB_OUTPUT
            
            # Comment on PR
            gh pr comment ${{ steps.pr.outputs.pr-number }} --body "‚è≥ **Release preparation waiting...**

CI checks are still running. Please wait for them to complete before preparing the release.

Running checks:
$(echo "$CHECK_RUNS" | jq -r '.check_runs[] | select(.status != "completed") | "- " + .name')"
            exit 1
          fi
          
          # Check if all required checks passed
          FAILED_CHECKS=$(echo "$CHECK_RUNS" | jq -r '.check_runs[] | select(.conclusion != "success" and .conclusion != "skipped" and .conclusion != null) | .name' | wc -l)
          
          if [ "$FAILED_CHECKS" -gt 0 ]; then
            echo "‚ùå CI checks failed. Found $FAILED_CHECKS failed checks."
            echo "ci-status=failed" >> $GITHUB_OUTPUT
            
            # Comment on PR
            gh pr comment ${{ steps.pr.outputs.pr-number }} --body "‚ùå **Release preparation blocked**

CI checks have failed. Please fix the failing checks before preparing the release.

Failed checks:
$(echo "$CHECK_RUNS" | jq -r '.check_runs[] | select(.conclusion != "success" and .conclusion != "skipped" and .conclusion != null) | "- " + .name + " (" + .conclusion + ")"')"
            exit 1
          fi
          
          echo "‚úÖ All CI checks passed!"
          echo "ci-status=success" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.pr.outputs.head-sha }}
          fetch-depth: 0

      - name: Setup workspace
        uses: ./.github/actions/setup-workspace

      - name: Detect affected packages
        id: detect
        uses: ./.github/actions/detect-affected

      - name: React to comment
        uses: peter-evans/create-or-update-comment@v4
        with:
          comment-id: ${{ github.event.comment.id }}
          reactions: rocket

      - name: Prepare releases for affected packages
        if: steps.detect.outputs.has-packages == 'true'
        run: |
          echo "üöÄ Preparing releases for affected packages..."
          
          # Process each affected package
          PACKAGES=$(echo '${{ steps.detect.outputs.packages }}' | jq -r '.[]')
          
          for package in $PACKAGES; do
            echo "üì¶ Processing $package..."
            
            PACKAGE_PATH="packages/$package"
            CURRENT_VERSION=$(jq -r '.version' $PACKAGE_PATH/package.json)
            PACKAGE_NAME=$(jq -r '.name' $PACKAGE_PATH/package.json)
            
            # Check if RELEASE_NOTES.md exists and has Release Candidate section
            RELEASE_NOTES_FILE="$PACKAGE_PATH/RELEASE_NOTES.md"
            
            if [ -f "$RELEASE_NOTES_FILE" ]; then
              echo "üìã Analyzing release notes for version bump type..."
              
              # Extract Release Candidate section (between "## Release Candidate" and next "##" or "---")
              RELEASE_CANDIDATE=$(sed -n '/## Release Candidate/,/^##\|^---/p' "$RELEASE_NOTES_FILE" | head -n -1)
              
              # Determine version bump type based on content
              BUMP_TYPE="patch"  # default
              
              if echo "$RELEASE_CANDIDATE" | grep -q "### ‚ö†Ô∏è Breaking Changes" && \
                 echo "$RELEASE_CANDIDATE" | grep -q "^- break:"; then
                BUMP_TYPE="major"
              elif echo "$RELEASE_CANDIDATE" | grep -q "### ‚ú® Features" && \
                   echo "$RELEASE_CANDIDATE" | grep -q "^- feat:"; then
                BUMP_TYPE="minor"
              fi
              
              echo "üìã Detected bump type: $BUMP_TYPE based on release notes"
            else
              echo "‚ö†Ô∏è No RELEASE_NOTES.md found, defaulting to patch"
              BUMP_TYPE="patch"
            fi
            
            # Calculate new version based on bump type
            IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
            case $BUMP_TYPE in
              "major")
                NEW_VERSION="$((MAJOR + 1)).0.0"
                ;;
              "minor")
                NEW_VERSION="$MAJOR.$((MINOR + 1)).0"
                ;;
              "patch")
                NEW_VERSION="$MAJOR.$MINOR.$((PATCH + 1))"
                ;;
            esac
            
            echo "üìã $PACKAGE_NAME: $CURRENT_VERSION ‚Üí $NEW_VERSION ($BUMP_TYPE)"
            
            # Update package.json with new version
            cd $PACKAGE_PATH
            pnpm version $NEW_VERSION --no-git-tag-version
            cd - > /dev/null
            
            # Update RELEASE_NOTES.md if it exists
            if [ -f "$RELEASE_NOTES_FILE" ]; then
              echo "üìù Updating release notes..."
              
              # Create new release section and move Release Candidate content
              RELEASE_DATE=$(date -u +%Y-%m-%d)
              
              # Create temporary file with updated release notes
              {
                # Keep everything before Release Candidate
                sed -n '1,/## Release Candidate/p' "$RELEASE_NOTES_FILE" | head -n -1
                
                # Add new empty Release Candidate section
                echo "## Release Candidate (Unreleased)"
                echo ""
                echo "### üêõ Bug Fixes"
                echo ""
                echo "### ‚ú® Features"
                echo ""
                echo "### üîß Maintenance"
                echo ""
                echo "### ‚ö†Ô∏è Breaking Changes"
                echo ""
                echo "---"
                echo ""
                
                # Add new release section with previous Release Candidate content
                echo "## $NEW_VERSION ($RELEASE_DATE)"
                echo ""
                sed -n '/## Release Candidate/,/^---$/p' "$RELEASE_NOTES_FILE" | tail -n +3 | head -n -2
                echo ""
                
                # Keep all previous releases
                sed -n '/^---$/,$p' "$RELEASE_NOTES_FILE" | tail -n +2
              } > "${RELEASE_NOTES_FILE}.tmp"
              
              mv "${RELEASE_NOTES_FILE}.tmp" "$RELEASE_NOTES_FILE"
              echo "‚úÖ Updated release notes"
            fi
            
            # Create patch file for all changes
            git add $PACKAGE_PATH/package.json $PACKAGE_PATH/RELEASE_NOTES.md
            git diff --staged > ${package}-version.patch
            
            # Create metadata
            cat > ${package}-version.json << EOF
          {
            "package": "$package",
            "name": "$PACKAGE_NAME",
            "currentVersion": "$CURRENT_VERSION",
            "newVersion": "$NEW_VERSION",
            "bumpType": "$BUMP_TYPE",
            "preparedAt": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "preparedBy": "${{ github.event.comment.user.login }}",
            "prNumber": ${{ steps.pr.outputs.pr-number }},
            "headSha": "${{ steps.pr.outputs.head-sha }}"
          }
          EOF
            
            echo "‚úÖ Created release preparation for $package"
          done

      - name: Upload release artifacts
        if: steps.detect.outputs.has-packages == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: release-prep-${{ github.run_id }}
          path: |
            *-version.patch
            *-version.json
          retention-days: 30

      - name: Create release summary
        if: steps.detect.outputs.has-packages == 'true'
        run: |
          cat > release-summary.json << EOF
          {
            "prNumber": ${{ steps.pr.outputs.pr-number }},
            "headSha": "${{ steps.pr.outputs.head-sha }}",
            "baseSha": "${{ steps.pr.outputs.base-sha }}",
            "preparedAt": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "preparedBy": "${{ github.event.comment.user.login }}",
            "workflowRunId": "${{ github.run_id }}",
            "packages": ${{ steps.detect.outputs.packages }},
            "packageCount": ${{ steps.detect.outputs.package-count }}
          }
          EOF

      - name: Upload release summary
        if: steps.detect.outputs.has-packages == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: release-summary-${{ github.run_id }}
          path: release-summary.json
          retention-days: 30

      - name: Generate release preview
        if: steps.detect.outputs.has-packages == 'true'
        run: |
          echo "üìù Generating release preview..."
          
          cat > release-preview.md << 'EOF'
          ## üöÄ Release Prepared by @${{ github.event.comment.user.login }}
          
          **Packages ready for release:** ${{ steps.detect.outputs.package-count }}
          
          ### üì¶ Release Details:
          
          EOF
          
          # Add details for each package
          PACKAGES=$(echo '${{ steps.detect.outputs.packages }}' | jq -r '.[]')
          
          for package in $PACKAGES; do
            if [ -f "${package}-version.json" ]; then
              PACKAGE_NAME=$(jq -r '.name' "${package}-version.json")
              CURRENT_VERSION=$(jq -r '.currentVersion' "${package}-version.json")
              NEW_VERSION=$(jq -r '.newVersion' "${package}-version.json")
              BUMP_TYPE=$(jq -r '.bumpType' "${package}-version.json")
              
              # Determine emoji based on bump type
              case $BUMP_TYPE in
                "major") EMOJI="üö®" ;;
                "minor") EMOJI="‚ú®" ;;
                "patch") EMOJI="üêõ" ;;
                *) EMOJI="üì¶" ;;
              esac
              
              cat >> release-preview.md << EOF
          #### $EMOJI \`$PACKAGE_NAME\`
          - **Current Version**: \`$CURRENT_VERSION\`
          - **New Version**: \`$NEW_VERSION\`
          - **Bump Type**: \`$BUMP_TYPE\`
          
          EOF
            fi
          done
          
          cat >> release-preview.md << 'EOF'
          
          **When this PR is merged**, these packages will be automatically published to npm and GitHub releases created.
          
          ---
          *ü§ñ Prepared by release preparation workflow using accumulated Release Candidate entries*
          EOF

      - name: Post release preview comment
        if: steps.detect.outputs.has-packages == 'true'
        uses: peter-evans/create-or-update-comment@v4
        with:
          issue-number: ${{ steps.pr.outputs.pr-number }}
          body-path: release-preview.md

      - name: Post no packages comment
        if: steps.detect.outputs.has-packages == 'false'
        uses: peter-evans/create-or-update-comment@v4
        with:
          issue-number: ${{ steps.pr.outputs.pr-number }}
          body: |
            ## ‚ÑπÔ∏è No Packages to Release
            
            No packages with publish targets were affected by this PR.
            The changes appear to be documentation, configuration, or non-publishable code.
            
            ---
            *ü§ñ Release preparation workflow*