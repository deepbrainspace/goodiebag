name: Release

on:
  push:
    branches:
      - main
      - develop
    paths:
      - 'packages/**'
      - 'apps/**'
      - 'libs/**'
      - 'package.json'
      - 'pnpm-lock.yaml'

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false

jobs:
  # Phase 1: Detect affected packages (reuse CI logic)
  detect-affected:
    name: üîç Detect Affected Packages
    runs-on: ubuntu-latest
    outputs:
      packages: ${{ steps.detect.outputs.packages }}
      has-packages: ${{ steps.detect.outputs.has-packages }}
      package-count: ${{ steps.detect.outputs.package-count }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 9.0.0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Set SHAs for NX
        uses: nrwl/nx-set-shas@v4
        with:
          main-branch-name: 'main'

      - name: Detect affected packages
        id: detect
        run: |
          # Get affected projects with publish target
          AFFECTED=$(nx show projects --affected --with-target=publish --json || echo '[]')
          echo "üîç Affected packages detected: $AFFECTED"
          
          if [ "$AFFECTED" = "[]" ] || [ -z "$AFFECTED" ]; then
            echo "packages=[]" >> $GITHUB_OUTPUT
            echo "has-packages=false" >> $GITHUB_OUTPUT
            echo "package-count=0" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è No affected packages found"
          else
            PACKAGE_COUNT=$(echo $AFFECTED | jq length)
            echo "packages=$AFFECTED" >> $GITHUB_OUTPUT
            echo "has-packages=true" >> $GITHUB_OUTPUT
            echo "package-count=$PACKAGE_COUNT" >> $GITHUB_OUTPUT
            echo "üéØ Found $PACKAGE_COUNT affected packages: $AFFECTED"
          fi

  # Phase 2: Download version mapping from CI
  download-versions:
    name: üì• Download Version Mapping
    needs: detect-affected
    if: needs.detect-affected.outputs.has-packages == 'true'
    runs-on: ubuntu-latest
    outputs:
      version-mapping: ${{ steps.load-versions.outputs.mapping }}
    
    steps:
      - name: Download version mapping from CI
        uses: actions/download-artifact@v4
        with:
          name: version-mapping
          github-token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Load version mapping
        id: load-versions
        run: |
          echo "üì• Loading version mapping from CI analysis..."
          if [ -f version-mapping.json ]; then
            MAPPING=$(cat version-mapping.json)
            echo "üìã Version mapping loaded:"
            echo "$MAPPING" | jq .
            echo "mapping=$MAPPING" >> $GITHUB_OUTPUT
          else
            echo "‚ùå No version mapping found - falling back to patch versions"
            echo '{}' > fallback-mapping.json
            echo "mapping={}" >> $GITHUB_OUTPUT
          fi

  # Phase 3: NPM Publish (parallel per package)
  npm-publish:
    name: üì¶ NPM Publish
    needs: [detect-affected, download-versions]
    if: needs.detect-affected.outputs.has-packages == 'true'
    strategy:
      matrix:
        package: ${{ fromJSON(needs.detect-affected.outputs.packages) }}
      fail-fast: false
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 9.0.0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Cache NX (restore from CI)
        uses: actions/cache@v4
        with:
          path: .nx/cache
          key: nx-${{ runner.os }}-build-${{ matrix.package }}-${{ github.sha }}
          restore-keys: |
            nx-${{ runner.os }}-build-${{ matrix.package }}-

      - name: Build ${{ matrix.package }} (use cache)
        run: |
          echo "üèóÔ∏è Building ${{ matrix.package }} (should hit cache)..."
          nx build ${{ matrix.package }}

      - name: Apply semantic version
        id: version
        run: |
          echo "üì¶ Preparing ${{ matrix.package }} for publishing..."
          
          # Get package info
          PACKAGE_PATH="packages/${{ matrix.package }}"
          CURRENT_VERSION=$(jq -r '.version' $PACKAGE_PATH/package.json)
          PACKAGE_NAME=$(jq -r '.name' $PACKAGE_PATH/package.json)
          
          # Get version from CI analysis
          VERSION_MAPPING='${{ needs.download-versions.outputs.version-mapping }}'
          
          if [ "$VERSION_MAPPING" != "{}" ] && [ -n "$VERSION_MAPPING" ]; then
            NEW_VERSION=$(echo "$VERSION_MAPPING" | jq -r --arg pkg "${{ matrix.package }}" '.[$pkg].version // empty')
            BUMP_TYPE=$(echo "$VERSION_MAPPING" | jq -r --arg pkg "${{ matrix.package }}" '.[$pkg].bumpType // "patch"')
            
            if [ -z "$NEW_VERSION" ] || [ "$NEW_VERSION" = "null" ]; then
              echo "‚ö†Ô∏è No version found in mapping for ${{ matrix.package }}, calculating patch bump"
              NEW_VERSION=$(echo $CURRENT_VERSION | awk -F. '{print $1"."$2"."($3+1)}')
              BUMP_TYPE="patch"
            fi
          else
            echo "‚ö†Ô∏è No version mapping available, calculating patch bump"
            NEW_VERSION=$(echo $CURRENT_VERSION | awk -F. '{print $1"."$2"."($3+1)}')
            BUMP_TYPE="patch"
          fi
          
          # Set npm tag based on branch and bump type
          if [ "${{ github.ref_name }}" = "main" ]; then
            if [ "$BUMP_TYPE" = "major" ]; then
              NPM_TAG="latest"
            else
              NPM_TAG="next"
            fi
          else
            NPM_TAG="dev"
          fi
          
          echo "üìã Package: $PACKAGE_NAME"
          echo "üìã Current Version: $CURRENT_VERSION"
          echo "üìã New Version: $NEW_VERSION ($BUMP_TYPE)"
          echo "üìã npm tag: $NPM_TAG"
          
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "npm-tag=$NPM_TAG" >> $GITHUB_OUTPUT
          echo "bump-type=$BUMP_TYPE" >> $GITHUB_OUTPUT
          echo "package-name=$PACKAGE_NAME" >> $GITHUB_OUTPUT

      - name: Update package version
        run: |
          cd packages/${{ matrix.package }}
          pnpm version ${{ steps.version.outputs.version }} --no-git-tag-version

      - name: Publish to NPM
        run: |
          echo "üì§ Publishing ${{ steps.version.outputs.package-name }} to npm..."
          
          # Configure npm
          echo "//registry.npmjs.org/:_authToken=${{ secrets.NPM_TOKEN }}" > ~/.npmrc
          
          # Publish to npm
          cd packages/${{ matrix.package }}
          pnpm publish --tag ${{ steps.version.outputs.npm-tag }} --access public
          
          echo "‚úÖ Successfully published ${{ steps.version.outputs.package-name }}@${{ steps.version.outputs.version }}"
        env:
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}

  # Phase 4: GitHub Releases (parallel per package)
  github-release:
    name: üè∑Ô∏è GitHub Release
    needs: [detect-affected, download-versions]
    if: needs.detect-affected.outputs.has-packages == 'true'
    strategy:
      matrix:
        package: ${{ fromJSON(needs.detect-affected.outputs.packages) }}
      fail-fast: false
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Create package tarball
        run: |
          cd packages/${{ matrix.package }}
          pnpm pack
          mv *.tgz ../../

      - name: Create GitHub release for ${{ matrix.package }}
        run: |
          echo "üè∑Ô∏è Creating GitHub release for ${{ matrix.package }}..."
          
          # Get package info
          PACKAGE_PATH="packages/${{ matrix.package }}"
          PACKAGE_NAME=$(jq -r '.name' $PACKAGE_PATH/package.json)
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          
          # Get version from CI analysis (same as publish job)
          VERSION_MAPPING='${{ needs.download-versions.outputs.version-mapping }}'
          
          if [ "$VERSION_MAPPING" != "{}" ] && [ -n "$VERSION_MAPPING" ]; then
            NEW_VERSION=$(echo "$VERSION_MAPPING" | jq -r --arg pkg "${{ matrix.package }}" '.[$pkg].version // empty')
            BUMP_TYPE=$(echo "$VERSION_MAPPING" | jq -r --arg pkg "${{ matrix.package }}" '.[$pkg].bumpType // "patch"')
            
            if [ -z "$NEW_VERSION" ] || [ "$NEW_VERSION" = "null" ]; then
              CURRENT_VERSION=$(jq -r '.version' $PACKAGE_PATH/package.json)
              NEW_VERSION=$(echo $CURRENT_VERSION | awk -F. '{print $1"."$2"."($3+1)}')
              BUMP_TYPE="patch"
            fi
          else
            CURRENT_VERSION=$(jq -r '.version' $PACKAGE_PATH/package.json)
            NEW_VERSION=$(echo $CURRENT_VERSION | awk -F. '{print $1"."$2"."($3+1)}')
            BUMP_TYPE="patch"
          fi
          
          # Determine release type
          if [ "${{ github.ref_name }}" = "main" ]; then
            if [ "$BUMP_TYPE" = "major" ]; then
              RELEASE_TYPE="Major Release"
            elif [ "$BUMP_TYPE" = "minor" ]; then
              RELEASE_TYPE="Minor Release"
            else
              RELEASE_TYPE="Patch Release"
            fi
          else
            RELEASE_TYPE="Development Preview"
          fi
          
          # Create tag name
          TAG_NAME="${{ matrix.package }}-${NEW_VERSION}"
          
          # Get recent commits for release notes
          RECENT_COMMITS=$(git log --oneline -n 5 -- $PACKAGE_PATH/ | head -5 || echo "- Initial release")
          
          # Generate release notes
          cat > release-notes.md << EOF
          ## üöÄ $RELEASE_TYPE
          
          **Package**: \`$PACKAGE_NAME\`
          **Version**: \`$NEW_VERSION\` ($BUMP_TYPE)
          **Commit**: ${{ github.sha }}
          **Branch**: ${{ github.ref_name }}
          
          ### Installation
          
          \`\`\`bash
          # npm
          npm install $PACKAGE_NAME@$NEW_VERSION
          
          # pnpm
          pnpm add $PACKAGE_NAME@$NEW_VERSION
          
          # yarn
          yarn add $PACKAGE_NAME@$NEW_VERSION
          \`\`\`
          
          ### Recent Changes
          
          $(echo "$RECENT_COMMITS" | sed 's/^/- /')
          
          ---
          
          > üîÑ This is an automated release from the ${{ github.ref_name }} branch.
          EOF
          
          # Find tarball
          TARBALL=$(find . -name "*.tgz" -type f | head -1)
          if [ -z "$TARBALL" ]; then
            echo "‚ùå No tarball found for ${{ matrix.package }}"
            exit 1
          fi
          
          # Create release
          gh release create $TAG_NAME $TARBALL \
            --title "${{ matrix.package }} $NEW_VERSION" \
            --notes-file release-notes.md \
            --prerelease=true \
            --target ${{ github.sha }}
          
          echo "‚úÖ GitHub release created: $TAG_NAME"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Phase 5: Commit version updates back to repo
  finalize:
    name: üîÑ Commit Version Updates
    needs: [detect-affected, download-versions, npm-publish, github-release]
    if: needs.detect-affected.outputs.has-packages == 'true'
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Setup git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Download release notes
        uses: actions/download-artifact@v4
        with:
          pattern: release-notes-*
          merge-multiple: true

      - name: Update package versions and commit
        run: |
          echo "üîÑ Updating package versions..."
          
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          CHANGED_FILES=""
          RELEASED_PACKAGES=""
          
          # Get version mapping from CI analysis
          VERSION_MAPPING='${{ needs.download-versions.outputs.version-mapping }}'
          
          # Update each affected package
          echo '${{ needs.detect-affected.outputs.packages }}' | jq -r '.[]' | while read package; do
            PACKAGE_PATH="packages/$package"
            PACKAGE_NAME=$(jq -r '.name' $PACKAGE_PATH/package.json)
            CURRENT_VERSION=$(jq -r '.version' $PACKAGE_PATH/package.json)
            
            # Get semantic version from CI analysis
            if [ "$VERSION_MAPPING" != "{}" ] && [ -n "$VERSION_MAPPING" ]; then
              NEW_VERSION=$(echo "$VERSION_MAPPING" | jq -r --arg pkg "$package" '.[$pkg].version // empty')
              BUMP_TYPE=$(echo "$VERSION_MAPPING" | jq -r --arg pkg "$package" '.[$pkg].bumpType // "patch"')
              
              if [ -z "$NEW_VERSION" ] || [ "$NEW_VERSION" = "null" ]; then
                NEW_VERSION=$(echo $CURRENT_VERSION | awk -F. '{print $1"."$2"."($3+1)}')
                BUMP_TYPE="patch"
              fi
            else
              NEW_VERSION=$(echo $CURRENT_VERSION | awk -F. '{print $1"."$2"."($3+1)}')
              BUMP_TYPE="patch"
            fi
            
            echo "Updating $PACKAGE_PATH/package.json to $NEW_VERSION"
            cd $PACKAGE_PATH
            pnpm version $NEW_VERSION --no-git-tag-version
            cd - > /dev/null
            
            echo "$PACKAGE_PATH/package.json" >> changed_files.txt
            echo "- $PACKAGE_NAME@$NEW_VERSION ($BUMP_TYPE)" >> released_packages.txt
            
            # Also commit the release notes
            if [ -f "RELEASE_NOTES.md" ]; then
              cp "RELEASE_NOTES.md" "$PACKAGE_PATH/"
              echo "$PACKAGE_PATH/RELEASE_NOTES.md" >> changed_files.txt
              echo "  üìù Release notes updated" >> released_packages.txt
            fi
          done
          
          # Check if we have changes to commit
          if [ -f changed_files.txt ] && [ -s changed_files.txt ]; then
            git add $(cat changed_files.txt)
            
            # Create commit message
            cat > commit_message.txt << EOF
          chore: release versions
          
          üì¶ Automated semantic version updates from AI analysis
          
          Packages released:
          $(cat released_packages.txt)
          
          ü§ñ Generated with AI-Driven Release Pipeline
          
          Co-Authored-By: github-actions[bot] <github-actions[bot]@users.noreply.github.com>
          EOF
            
            git commit -F commit_message.txt
            git push origin ${{ github.ref_name }}
            echo "‚úÖ Version updates committed and pushed"
          else
            echo "‚ÑπÔ∏è No version files to commit"
          fi

  # Phase 6: Post release confirmation comment
  release-comment:
    name: üí¨ Post Release Confirmation
    needs: [detect-affected, download-versions, npm-publish, github-release, finalize]
    if: needs.detect-affected.outputs.has-packages == 'true'
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download version mapping
        uses: actions/download-artifact@v4
        with:
          name: version-mapping

      - name: Find PR that was merged
        id: find-pr
        run: |
          echo "üîç Finding the PR that was merged..."
          
          # Get the merge commit message to extract PR number
          MERGE_MESSAGE=$(git log -1 --pretty=%B)
          echo "Merge commit message: $MERGE_MESSAGE"
          
          # Extract PR number from merge commit message (format: "Merge pull request #123")
          PR_NUMBER=$(echo "$MERGE_MESSAGE" | grep -oP '(?<=#)\d+' | head -1)
          
          if [ -z "$PR_NUMBER" ]; then
            # Try GitHub API as fallback
            PR_NUMBER=$(gh api repos/${{ github.repository }}/commits/${{ github.sha }}/pulls --jq '.[0].number' 2>/dev/null || echo "")
          fi
          
          if [ -n "$PR_NUMBER" ]; then
            echo "‚úÖ Found PR #$PR_NUMBER"
            echo "pr-number=$PR_NUMBER" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Could not find PR number"
            exit 1
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate release confirmation comment
        run: |
          echo "üìù Generating release confirmation..."
          
          # Create comment header
          cat > release-comment.md << 'EOF'
          ## ‚úÖ Release Completed Successfully!
          
          All packages have been published to npm and GitHub releases have been created.
          
          ### üì¶ Published Packages:
          EOF
          
          # Parse version mapping and add package details
          VERSION_MAPPING=$(cat version-mapping.json)
          
          echo "$VERSION_MAPPING" | jq -r 'to_entries[] | "\(.key) \(.value.version) \(.value.bumpType)"' | while read package version bump_type; do
            PACKAGE_NAME=$(jq -r --arg pkg "$package" '.[$pkg].name // ("@deepbrainspace/" + $pkg)' packages/$package/package.json 2>/dev/null || echo "@deepbrainspace/$package")
            
            cat >> release-comment.md << EOF
          
          #### üì¶ \`$PACKAGE_NAME@$version\` ($bump_type)
          - **npm**: [\`npm install $PACKAGE_NAME@$version\`](https://www.npmjs.com/package/$PACKAGE_NAME/v/$version)
          - **GitHub Release**: [View Release](https://github.com/${{ github.repository }}/releases/tag/$package-v$version)
          - **Changelog**: [View RELEASE_NOTES.md](https://github.com/${{ github.repository }}/blob/main/packages/$package/RELEASE_NOTES.md)
          EOF
          done
          
          # Add footer
          cat >> release-comment.md << 'EOF'
          
          ---
          
          ### üöÄ Installation
          
          To install the latest versions:
          ```bash
          # Using npm
          npm install @deepbrainspace/[package-name]@latest
          
          # Using pnpm
          pnpm add @deepbrainspace/[package-name]@latest
          ```
          
          ### üìã Next Steps
          - Test the released packages in your projects
          - Report any issues in the [issue tracker](https://github.com/${{ github.repository }}/issues)
          
          ---
          *ü§ñ Automated by GitHub Actions Release Pipeline*
          EOF

      - name: Post release confirmation comment
        uses: peter-evans/create-or-update-comment@v4
        with:
          issue-number: ${{ steps.find-pr.outputs.pr-number }}
          body-path: release-comment.md

  # No affected packages notification
  no-packages:
    name: ‚ÑπÔ∏è No Packages to Release
    needs: detect-affected
    if: needs.detect-affected.outputs.has-packages == 'false'
    runs-on: ubuntu-latest
    
    steps:
      - name: Report status
        run: |
          echo "‚ÑπÔ∏è No packages with publish targets were affected by this push."
          echo "No releases will be created."