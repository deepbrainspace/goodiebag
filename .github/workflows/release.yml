name: Release

on:
  push:
    branches: [main]
    paths:
      - '**'                           # Include everything by default
      - '!packages/*/package.json'     # EXCLUDE package.json (version changes)
      - '!packages/*/RELEASE_NOTES.md' # EXCLUDE release notes

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false

jobs:
  # Phase 1: Check if this push is from a release-ready PR
  check-release:
    name: üîç Check Release Status
    runs-on: ubuntu-latest
    outputs:
      should-release: ${{ steps.check.outputs.should-release }}
      pr-number: ${{ steps.find-pr.outputs.pr-number }}
    
    steps:
      - name: Setup workspace
        uses: ./.github/actions/setup-workspace
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Find PR associated with merge commit
        id: find-pr
        run: |
          echo "üîç Finding PR associated with merge commit..."
          
          # Get merge commit message to extract PR number
          MERGE_MESSAGE=$(git log -1 --pretty=%B)
          echo "Merge commit message: $MERGE_MESSAGE"
          
          # Extract PR number from merge commit message (format: "Merge pull request #123")
          PR_NUMBER=$(echo "$MERGE_MESSAGE" | grep -oP '(?<=#)\d+' | head -1)
          
          if [ -z "$PR_NUMBER" ]; then
            # Try alternative method via GitHub API
            PR_NUMBER=$(gh api repos/${{ github.repository }}/commits/${{ github.sha }}/pulls --jq '.[0].number' 2>/dev/null || echo "")
          fi
          
          if [ -n "$PR_NUMBER" ]; then
            echo "‚úÖ Found associated PR #$PR_NUMBER"
            echo "pr-number=$PR_NUMBER" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Could not find PR number for this merge"
            exit 1
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Check if PR had prepare_release comment
        id: check
        run: |
          echo "üîç Checking if PR #${{ steps.find-pr.outputs.pr-number }} had prepare_release comment..."
          
          # Check for prepare_release comments on the PR
          COMMENTS=$(gh api repos/${{ github.repository }}/issues/${{ steps.find-pr.outputs.pr-number }}/comments --jq '.[].body')
          
          if echo "$COMMENTS" | grep -q "prepare_release"; then
            echo "‚úÖ PR had prepare_release comment - proceeding with release"
            echo "should-release=true" >> $GITHUB_OUTPUT
          else
            echo "‚ÑπÔ∏è PR did not have prepare_release comment - skipping release process"
            echo "should-release=false" >> $GITHUB_OUTPUT
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Phase 2: Apply patches and release
  apply-patches:
    name: üîÑ Apply Version Patches
    needs: check-release
    if: needs.check-release.outputs.should-release == 'true'
    runs-on: ubuntu-latest
    outputs:
      packages: ${{ steps.summary.outputs.packages }}
      has-packages: ${{ steps.summary.outputs.has-packages }}
      package-count: ${{ steps.summary.outputs.package-count }}
    
    steps:
      - name: Setup workspace
        uses: ./.github/actions/setup-workspace
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Find prepare-release workflow run for this PR
        id: find-prepare
        run: |
          echo "üîç Finding prepare-release workflow run for PR #${{ needs.check-release.outputs.pr-number }}..."
          
          # Get the prepare-release workflow run ID for this PR
          PREPARE_RUN_ID=$(gh api repos/${{ github.repository }}/actions/workflows/prepare-release.yml/runs \
            --jq ".workflow_runs[] | select(.pull_requests[]?.number == ${{ needs.check-release.outputs.pr-number }}) | .id" | head -1)
          
          if [ -n "$PREPARE_RUN_ID" ]; then
            echo "‚úÖ Found prepare-release run ID: $PREPARE_RUN_ID"
            echo "prepare-run-id=$PREPARE_RUN_ID" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Could not find prepare-release run ID"
            exit 1
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Download release summary from prepare-release
        uses: actions/download-artifact@v4
        with:
          name: release-summary-${{ steps.find-prepare.outputs.prepare-run-id }}
          run-id: ${{ steps.find-prepare.outputs.prepare-run-id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Read release summary
        id: summary
        run: |
          if [ -f "release-summary.json" ]; then
            echo "üìã Reading release summary from CI workflow..."
            cat release-summary.json
            
            PACKAGES=$(jq -r '.packages' release-summary.json)
            PACKAGE_COUNT=$(jq -r '.packageCount' release-summary.json)
            
            echo "packages=$PACKAGES" >> $GITHUB_OUTPUT
            echo "package-count=$PACKAGE_COUNT" >> $GITHUB_OUTPUT
            
            if [ "$PACKAGES" = "[]" ] || [ "$PACKAGE_COUNT" = "0" ]; then
              echo "has-packages=false" >> $GITHUB_OUTPUT
              echo "‚ÑπÔ∏è No packages to release"
            else
              echo "has-packages=true" >> $GITHUB_OUTPUT
              echo "üéØ Found $PACKAGE_COUNT packages to release: $PACKAGES"
            fi
          else
            echo "‚ùå No release summary found"
            echo "has-packages=false" >> $GITHUB_OUTPUT
            echo "packages=[]" >> $GITHUB_OUTPUT
            echo "package-count=0" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Download version patches from prepare-release
        if: steps.summary.outputs.has-packages == 'true'
        uses: actions/download-artifact@v4
        with:
          name: release-prep-${{ steps.find-prepare.outputs.prepare-run-id }}
          run-id: ${{ steps.find-prepare.outputs.prepare-run-id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Apply version patches to main branch
        if: steps.summary.outputs.has-packages == 'true'
        run: |
          echo "üîÑ Applying version patches to main branch..."
          
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Apply each package's patch
          PACKAGES=$(echo '${{ steps.summary.outputs.packages }}' | jq -r '.[]')
          
          # Build descriptive commit message
          COMMIT_TITLE="release: "
          COMMIT_BODY=""
          
          for package in $PACKAGES; do
            PATCH_FILE="${package}-version.patch"
            JSON_FILE="${package}-version.json"
            
            if [ -f "$PATCH_FILE" ] && [ -f "$JSON_FILE" ]; then
              echo "üì¶ Applying patch for $package..."
              
              # Apply the patch
              if git apply "$PATCH_FILE"; then
                PACKAGE_NAME=$(jq -r '.name' "$JSON_FILE")
                NEW_VERSION=$(jq -r '.newVersion' "$JSON_FILE")
                BUMP_TYPE=$(jq -r '.bumpType' "$JSON_FILE")
                
                # Add to commit message
                COMMIT_TITLE="${COMMIT_TITLE}${package}-v${NEW_VERSION}, "
                COMMIT_BODY="${COMMIT_BODY}
    - ${PACKAGE_NAME}@${NEW_VERSION} (${BUMP_TYPE})"
                
                echo "‚úÖ Applied version update for $package ‚Üí $NEW_VERSION"
              else
                echo "‚ùå Failed to apply patch for $package"
                echo "Patch content:"
                cat "$PATCH_FILE"
                exit 1
              fi
            else
              echo "‚ö†Ô∏è Missing patch files for $package"
            fi
          done
          
          # Remove trailing comma and space
          COMMIT_TITLE=$(echo "$COMMIT_TITLE" | sed 's/, $//')
          
          # Commit all version updates with detailed message
          git add packages/*/package.json packages/*/RELEASE_NOTES.md
          
          if ! git diff --staged --quiet; then
            git commit -m "${COMMIT_TITLE}${COMMIT_BODY}

            ü§ñ Automated release commit
            
            Co-Authored-By: github-actions[bot] <github-actions[bot]@users.noreply.github.com>"
            
            git push origin main
            echo "‚úÖ Version updates committed and pushed to main"
          else
            echo "‚ÑπÔ∏è No version changes to commit"
          fi

  # Phase 3: NPM Publish (parallel per package)
  npm-publish:
    name: üì¶ NPM Publish
    needs: [check-release, apply-patches]
    if: needs.apply-patches.outputs.has-packages == 'true'
    strategy:
      matrix:
        package: ${{ fromJSON(needs.apply-patches.outputs.packages) }}
      fail-fast: false
    runs-on: ubuntu-latest
    
    steps:
      - name: Setup workspace
        uses: ./.github/actions/setup-workspace

      - name: Build ${{ matrix.package }}
        run: |
          echo "üèóÔ∏è Building ${{ matrix.package }}..."
          nx build ${{ matrix.package }}

      - name: Get package info
        id: info
        run: |
          echo "üì¶ Getting package info for ${{ matrix.package }}..."
          
          PACKAGE_PATH="packages/${{ matrix.package }}"
          PACKAGE_NAME=$(jq -r '.name' $PACKAGE_PATH/package.json)
          VERSION=$(jq -r '.version' $PACKAGE_PATH/package.json)
          
          # Determine npm tag based on version
          if [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            MAJOR=$(echo $VERSION | cut -d. -f1)
            if [ "$MAJOR" -gt 0 ]; then
              NPM_TAG="latest"
            else
              NPM_TAG="next"
            fi
          else
            NPM_TAG="dev"
          fi
          
          echo "üìã Package: $PACKAGE_NAME"
          echo "üìã Version: $VERSION"
          echo "üìã npm tag: $NPM_TAG"
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "npm-tag=$NPM_TAG" >> $GITHUB_OUTPUT
          echo "package-name=$PACKAGE_NAME" >> $GITHUB_OUTPUT

      - name: Publish to NPM
        run: |
          echo "üì§ Publishing ${{ steps.info.outputs.package-name }} to npm..."
          
          # Configure npm
          echo "//registry.npmjs.org/:_authToken=${{ secrets.NPM_TOKEN }}" > ~/.npmrc
          
          # Publish to npm
          cd packages/${{ matrix.package }}
          pnpm publish --tag ${{ steps.info.outputs.npm-tag }} --access public
          
          echo "‚úÖ Successfully published ${{ steps.info.outputs.package-name }}@${{ steps.info.outputs.version }}"
        env:
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}

  # Phase 4: GitHub Releases (parallel per package)
  github-release:
    name: üè∑Ô∏è GitHub Release
    needs: [check-release, apply-patches]
    if: needs.apply-patches.outputs.has-packages == 'true'
    strategy:
      matrix:
        package: ${{ fromJSON(needs.apply-patches.outputs.packages) }}
      fail-fast: false
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Create package tarball
        run: |
          cd packages/${{ matrix.package }}
          pnpm pack
          mv *.tgz ../../

      - name: Create GitHub release for ${{ matrix.package }}
        run: |
          echo "üè∑Ô∏è Creating GitHub release for ${{ matrix.package }}..."
          
          PACKAGE_PATH="packages/${{ matrix.package }}"
          PACKAGE_NAME=$(jq -r '.name' $PACKAGE_PATH/package.json)
          VERSION=$(jq -r '.version' $PACKAGE_PATH/package.json)
          TAG_NAME="${{ matrix.package }}-v${VERSION}"
          
          # Use release notes if they exist
          if [ -f "$PACKAGE_PATH/RELEASE_NOTES.md" ]; then
            RELEASE_NOTES="$PACKAGE_PATH/RELEASE_NOTES.md"
          else
            # Generate simple release notes
            cat > release-notes.md << EOF
          ## üöÄ Release ${{ matrix.package }} v${VERSION}
          
          **Package**: \`$PACKAGE_NAME\`
          **Version**: \`$VERSION\`
          **Commit**: ${{ github.sha }}
          
          ### Installation
          
          \`\`\`bash
          npm install $PACKAGE_NAME@$VERSION
          \`\`\`
          
          ---
          
          > üîÑ This is an automated release from the main branch.
          EOF
            RELEASE_NOTES="release-notes.md"
          fi
          
          # Find tarball
          TARBALL=$(find . -name "*.tgz" -type f | head -1)
          if [ -z "$TARBALL" ]; then
            echo "‚ùå No tarball found for ${{ matrix.package }}"
            exit 1
          fi
          
          # Create release
          gh release create $TAG_NAME $TARBALL \
            --title "${{ matrix.package }} v$VERSION" \
            --notes-file "$RELEASE_NOTES" \
            --target ${{ github.sha }}
          
          echo "‚úÖ GitHub release created: $TAG_NAME"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Phase 5: Post release confirmation comment
  release-comment:
    name: üí¨ Post Release Confirmation
    needs: [check-release, apply-patches, npm-publish, github-release]
    if: needs.apply-patches.outputs.has-packages == 'true'
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Generate release confirmation comment
        run: |
          echo "üìù Generating release confirmation for PR #${{ needs.check-release.outputs.pr-number }}..."
          
          cat > release-comment.md << 'EOF'
          ## ‚úÖ Release Completed Successfully!
          
          All packages have been published to npm and GitHub releases have been created.
          
          ### üì¶ Published Packages:
          EOF
          
          # Add package details
          PACKAGES=$(echo '${{ needs.apply-patches.outputs.packages }}' | jq -r '.[]')
          
          for package in $PACKAGES; do
            PACKAGE_PATH="packages/$package"
            if [ -d "$PACKAGE_PATH" ]; then
              PACKAGE_NAME=$(jq -r '.name' $PACKAGE_PATH/package.json)
              VERSION=$(jq -r '.version' $PACKAGE_PATH/package.json)
              
              cat >> release-comment.md << EOF
          
          #### üì¶ \`$PACKAGE_NAME@$VERSION\`
          - **npm**: [\`npm install $PACKAGE_NAME@$VERSION\`](https://www.npmjs.com/package/$PACKAGE_NAME/v/$VERSION)
          - **GitHub Release**: [View Release](https://github.com/${{ github.repository }}/releases/tag/$package-v$VERSION)
          EOF
            fi
          done
          
          cat >> release-comment.md << 'EOF'
          
          ---
          
          ### üöÄ Installation
          
          To install the latest versions:
          ```bash
          # Using npm
          npm install @deepbrainspace/[package-name]@latest
          
          # Using pnpm
          pnpm add @deepbrainspace/[package-name]@latest
          ```
          
          ---
          *ü§ñ Automated by GitHub Actions Release Pipeline*
          EOF

      - name: Post release confirmation comment
        uses: peter-evans/create-or-update-comment@v4
        with:
          issue-number: ${{ needs.check-release.outputs.pr-number }}
          body-path: release-comment.md

  # No release needed
  no-release:
    name: ‚ÑπÔ∏è No Release Needed
    needs: check-release
    if: needs.check-release.outputs.should-release == 'false'
    runs-on: ubuntu-latest
    
    steps:
      - name: Report status
        run: |
          echo "‚ÑπÔ∏è This merge was not marked for release."
          echo "To release packages, comment 'prepare_release' on PRs."